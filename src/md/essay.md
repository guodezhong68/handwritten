##js的作用域
全局作用域  
函数作用域  
es6块级作用域  

##js事件流
指的是浏览器处理事件的方式
三个阶段
捕获阶段
：事件冲最外层的节点（文档对象）开始，逐级向下传播，直到达到事件的目标节点。
目标阶段
：事件到达目标节点，触发目标节点上的事件处理函数。
冒泡阶段
：事件冲目标节点开始，逐级向上传播，直到达到最外层的节点（文档对象）。

阻止冒泡
event.stopPropagation()
取消事件的默认行为
event.preventDefault()

##js事件轮询机制 (Event Loop)
是一种异步编程模型，用于处理js中的事件和回调函数。js事件轮询机制可以使得单线程的js能够处理多个任务，从而实现异步编程。  
宏任务  
    通常包括一些花费较长时间的操作，定时器、事件回调等
    当一个宏任务执行完毕后，js引擎会检查是否存在未执行的微任务，存在则执行这些微任务。所有任务执行完毕后，js会再次执行宏任务。  
微任务  
    通常包括一些尽快执行的操作，Promise回调函数、MutationObserver（监视dom的变动）的回调函数等
执行顺序如下：  
    执行当前宏任务中的同步代码，直到遇到第一个宏任务或微任务。\
    如果遇到微任务，则立即执行所有微任务。微任务执行完毕后，js引擎会检查是否存在新的微任务，如果存在则重复执行该步骤，直到所有微任务执行完毕。
    如果遇到宏任务，则将它添加到宏任务队列中，继续执行下一个同步代码。  
    当前宏任务执行完毕后，js引擎会检查宏任务队列是否为空。如果不为空，则执行队列中的第一个宏任务，重复执行该步骤直到宏任务为空。
    当前事件轮询结束，等待下一次事件的触发。  
    需要注意的是，js中的事件轮询是单线程的，所有任务都是同一个线程中执行的，不能同时执行两个任务。如果当前宏任务执行的时间太长，会阻塞其他宏任务的执行，从而导致应用程序的性能问题.
   因此，再编写js代码时，应该尽可能避免长时间的同步操作，而是使用异步操作，保证应用程序的性能和响应速度。

##原型链
是javascript中实现继承的一种机制。每个实例对象都有一个私有属性（称之为_proto_）指向它的构造函数的原型对象（prototype）
该原型对象也有一个自己的原型对象，层层向上直到一个对象的原型对象为null\
缺点\
在原型链上查找属性比较耗时，对性能有副作用，这在性能要求苛刻（一般情况无影响）的情况下很重要。
另外，试图访问不存在的属性时会遍历整个原型链。

##作用域
是指程序代码中定义变量的区域，它规定了变量的可见性和生命周期。在js中，作用域可以分为全局作用域和函数作用域两种，它们之间存在嵌套关系，也就是所谓的作用域链。

##闭包的作用和原理以及使用场景
是指一个函数内部定义的函数，并且该函数可以访问外部函数的变量和参数。在js中，由于函数是一等对象，因此可以将函数作为返回值，从而形成闭包。
使用场景  
：保存变量状态和私有化变量和函数
    用于事件处理和回调函数
    用于封装类和模块
    用于实现颗粒化和函数式编程
    用于解决循环中异步问题
    用于实现缓存和记忆化等功能
防止闭包引起的内存泄漏：
    避免创建不必要的闭包
    及时释放闭包
    使用模块模式
    使用箭头函数
    避免循环引用
##es6新特性？箭头函数和普通函数的区别？
常用的新特性包括：
块级作用域：通过let和const声明的变量只在当前块级作用域中有效
箭头函数：使用 => 符号定义的函数，具有简化的语法和自动绑定this上下文的特点
模板字符串：使用反引号``和${}操作符，可以方便地拼接字符串的变量
解构赋值：可以将数组或对象的值解构赋给变量
类和继承：引入class和extends关键字，使得js支持面向对象编程
Promise和async/await:用于处理异步编程的新特性
箭头函数和普通函数的区别
箭头函数没有自己的this上下文，它的this上下文继承自外部作用域，因此不能使用call()、apply()或bind()方法改变this上下文
箭头函数没有自己的arguments对象，如果需要获取函数参数，可以使用rest参数或者展开运算符
箭头函数不能作为构造函数使用，不能使用new关键字创建对象
##js中如何判断数据类型
typeof value
"undefined"表示未定义
"boolean"表示布尔值
"number"表示数值
"string"表示字符串
"symbol"表示符号
"object"表示对象或null
"function"表示函数
object instanceof constructor
Object.prototype.toString.call(value)
##==和===有什么区别
==进行比较时会先进行类型转换
##合并对象
Object.assign()或拓展运算符

##虚拟滚动的原理
1.计算列表项高度
2.计算列表高度和可见区域高度
3.计算每一段的高度和起始位置
4.监听滚动事件
5.渲染可见区域内的DOM元素

##虚拟列表的原理
1.计算列表容器的高度以及每条数据的高度
2.根据容器高度的每条数据的高度计算可见区域内需要展示的数据数量
3.根据当前滚动条的位置和可见区域内需要展示的数据数量，计算出需要渲染的数据的起始位置和结束位置
4.在滚动容器中根据需要渲染的数据的起始位置和结束位置渲染对应的数据项
5.监听滚动事件，当滚动条滚动时，重复上述步骤进行动态渲染



#前端性能
前端性能优化是为了提高网页的加载速度和响应速度，提升用户体验和用户满意度，同时还能减少服务器的负载压力，从而提高整个应用程序的性能和稳定性，提高用户留存率。
性能优化2-5-8原则
2：页面的加载时间应该控制在2秒以内，这是用户能够接受的最短时间
5：页面的加载时间在5秒以内，用户对页面加载速度的不满意度开始上升
8：页面的加载时间超过8秒，用户的流失率将急剧增加，用户很可能会放弃访问该页面。

压缩和合并文件
CDN加速
懒加载
缓存优化
##前端性能指标具体有哪些
两大块：
页面加载时间
    首字节时间
    DNS解析时间
    TCP连接时间
    SSL加密时间
    DOM渲染时间
渲染性能
    FPS
    CPU占用率
    GPU占用率
    页面重排
    避免强制同步布局
    前端代码性能
    代码压缩比
    代码体积
    javascript解析时间
    静态资源优化
    用户体验
    页面响应时间
    页面交互速度
    错误率
#如何通过指标定位问题
（FCP）页面加载速度缓慢，用户长时间等待页面渲染
可以通过优化HTML、CSS、JavaScript代码，减少HTTP请求数量、使用延迟加载等方法来加速页面加载速度
（LCP）页面上最大的可见内容块加载速度缓慢，用户长时间等待页面渲染
可以通过优化图片、视频等资源大小、减少不必要的渲染等方法来加速页面加载速度
（TTI）页面加载完成后，用户无法立即与页面进行交互
可以通过优化JavaScript和CSS代码、减少不必要的资源请求等方法来加速页面交互响应时间
（TBT）页面加载完成后，用户与页面上的元素交互时出现阻塞，响应时间缓慢
可以通过JavaScript代码、减少不必要的资源请求等方法来加速页面交互响应时间
#性能优化具体实施
html：
压缩HTML文件大小
使用异步和延迟加载
减少DOM元素数量
css：
减少CSS文件的大小
减少CSS选择器的复杂度
避免使用过多的CSS图像
避免使用CSS表达式
使用CSS渲染合成层
js：
减少dom的操作
避免使用全局变量
避免使用with语句
避免使用eval函数
尽量使用原生方法
将JavaScript文件放到页面底部
使用缓存
使用WebWorker
react：
避免在render()函数中使用bind()
避免在render()中使用复杂运算
使用React.lazy()来按需加载组件
避免不必要的数据传输
避免不必要的重新渲染
使用React的批量更新机制
使用memoization和缓存
使用React Profiler工具进行性能分析
使用React DevTools进行调试
包体积：
代码拆分
按需加载
压缩代码
静态资源优化
Tree Shaking
开启gzip压缩
使用CDN

静态资源：
压缩文件大小
使用WebP格式
使用SVG格式
去除无用资源
合并文件
使用缓存
使用CDN

图片优化：
压缩图片大小
使用WebP格式
优化图片格式
使用响应式图片
懒加载图片
CDN加速
去除无用图片

白屏：
减少首屏加载体积
加载优先级排序
延迟加载非关键资源
使用浏览器缓存
避免阻塞渲染
代码优化
使用CDN

首屏加载速度：
缓存优化
启用浏览器缓存
使用CDN缓存静态资源
使用本地存储
优化缓存策略
压缩缓存资源
使用缓存代理
避免缓存穿透
避免缓存雪崩

网络优化：
减少HTTP请求
使用CDN
压缩文件
预加载和懒加载
HTTP缓存
使用Web Worker
使用HTTP/2
前端性能监控

Web Worker
Web Worker是HTML5提供的一项新技术，允许前端在单独的线程中执行代码，从而提高性能和响应速度。

动画：
前端动画通常会涉及到DOM元素的变化和重绘，这些操作可能会对页面性能造成负面影响

##前端展示大批量图片如何优化
图片懒加载
图片压缩
CDN加速
WebP格式
懒加载占位符

##前端白屏高的原因
网络问题
资源加载问题
js错误无法正常渲染
dom结构错误
渲染性能问题

##单页面应用首屏为什么加载慢
大量js和css文件加载慢
数据请求过多或数据请求太慢
大量图片加载慢
过多的渲染和重绘操作
网络问题

##单页面应用首屏白屏率为什么这么高
js加载时间过长
服务器响应时间慢
模板渲染速度慢
静态资源未缓存
不合理的图片加载策略

##前端预渲染的好处
提升页面的加载速度
减轻服务器负担
优化搜索引擎的爬取
提高首屏渲染速度
